>>>PCX.DOC

A. Copyright Information

Images.Hpp and Images.Cpp along with this document file are copyright
1991 by the Gamers Programming Workshop, GAMERS forum, Compuserve (GO GAMERS,
section 11). The code and related document are free for use, distribution,
and modification, provided the following conditions are met:

	1. no commercial use of this source code or documents is permitted.
	2. no fee may be charged beyond disk duplication cost for any of this
	   material.
	3. If the code is upgraded or modified a copy of the modification must
	   be uploaded to section 11 of the GAMERS forum on Compuserve. All
	   modifications must be documented and the author's name included in
	   the source code header block, and the subsequent file package must
	   include all the original doc files as well as any additions. If you
	   modify or add functions please update the function list below.


B. Description

The IMAGES.HPP file provides the definition of a class image, from which
is descended class pcx. Images is a base class containing information
generic to any full screen image, such as where it's located on disk, where
it's located in memory, what it's status is, etc. The descendent class, pcx,
adds methods and data specific to the pcx class of images. It's expected that
at some point new classes will be descended from images to accomodate other
popular graphics formats.

The defintion of the images class is as follows:

class image {
	public:
	p_rec palette;                        // holds the default image palette
	char fpath[80];                       // stores the disk path to image
	char getstatus() {return(status);}    // returns status of last op
										  // see err codes in IMAGES.HPP
	protected:
	char in_ram;                          // 1 if image in ram, 0 if not
	char packed;                          // 1 if packed in ram, 0 if not
	char status;                          // returned by getstatus()
	char far *buffer;                     // pointer for ram buffer if any
};

This is the definition for the descendent pcx class:

class pcx : public image {
	public:
	pcx(char *fspec);                     // constructor
	char load(char method);               // load into ram packed or unpacked
	void unload();                        // unload from ram
	char display(char fadetype);          // display image using fadetype
	void remove(char fadetype);           // remove image using fadetype
	~pcx();								  // destructor
	private:
	char unpacktoram(char far *dest,      // internal, unpack to memory
					 unsigned numbytes);

};

C. Function interface.

*****************************************************************************

images::getstatus()

getstatus returns the current value of the status member variable. This var
holds the result of operations executed in the constructor. All other methods
explicitly return an error code if applicable. Call getstatus after declaring
an instance of a pcx class object.

*****************************************************************************

pcx::pcx(char *fspec);

The constructor opens the file and determines if it is a valid 256 color
mode 13h pcx file. If so, it loads the palette into the palette member
structure, ignores the header (this can be easily changed if you need the
header for something), and sets several object data members to initial
values. It returns error codes as defined in IMAGES.HPP

*****************************************************************************

char pcx::load(char method);

load() attempts to get the image data from disk into memory in order to
speed display. The method variable may have one of three values (constants
defined in IMAGES.HPP). They are Packed, Unpacked, and Bestfit. Packed
causes the data to be loaded into memory in compressed form. Unpacked causes
the data to be decompressed to a memory buffer. Bestfit causes the function
to determine if the data will be stored Packed or Unpacked based on avail-
able memory. In any of these cases the function will return a MemErr if the
minimum required memory is not available. If the load succeeds a pointer
to the buffer will be stored in the buffer member variable for later use,
and the in_ram and packed member variables will be updated to reflect the
pcx object's status.

*****************************************************************************

void pcx::unload();

unload() removes the image data from memory, frees the buffer, and updates
the values of the member status variables in_ram and packed. If the image
is not loaded the function returns an UnknownErr.

*****************************************************************************

char pcx::display(char fadetype);

display() is the heart of the pcx class. It will cause the object to be disp-
layed on screen regardless of it's current status. If the image is still on
disk it will be displayed from there. Likewise if it is in ram packed or
unpacked. The fadetype argument can have one of the constant values defined
in IMAGES.HPP. Of the possible fades and dissolves all but SoftFade and
SnapWipe require that the image data be in a 64000 byte memory buffer, un-
packed. If this memory is not available and one of the other fades has been
requested the function will return a MemErr. You can call display regardless
of where the image is currently located. Display will be fastest if the
image is located in ram unpacked, and slowest if the image is on disk. One
possible method would be to use a load(Bestfit) call on a series of images,
and then display them. In this case you do not have to check for available
memory. The performance of the display calls will depend on how much memory
is available at runtime.

*****************************************************************************

void pcx::remove(char fadetype);

remove() performs the opposite task of display(). It will blank the screen
using the fade requested. No memory is required, no value is returned, and
the status of the pcx object is not affected.

*****************************************************************************

pcx::~pcx();

The destructor frees any memory allocated to the image buffer, nulls all
pointers and closes down the object.

*****************************************************************************

char pcx::unpacktoram(char far *dest, unsigned numbytes);

This is a private method used by the display and load functions to unpack
the rle encoded pcx data. It can possibly return errorcodes for file errors.
If it returns an error code to either display or load that function will
return a SecondaryErr to it's caller.

*****************************************************************************

D. Example of useage

#include <dos.h>
#include "images.hpp"

void main() {
	char result;

	setgraphmode();

	// initialize three pcx objects with full error checking. Pcx files
	// should be in the current directory.

	pcx pcx1("test1.pcx");
	if (pcx1.getstatus() != NoErr) {
		reporterr(pcx1.getstatus(),"object constructor");
		return;
	}
	pcx pcx2("test2.pcx");
	if (pcx2.getstatus() != NoErr) {
		reporterr(pcx2.getstatus(),"object constructor");
		return;
	}
	pcx pcx3("test3.pcx");
	if (pcx3.getstatus() != NoErr) {
		reporterr(pcx3.getstatus(),"object constructor");
		return;
	}

	// load the three files Bestfit. Ultimately we'd like them all in
	// ram and unpacked to speed up the display.

	result = pcx1.load(Bestfit);
	if ((result != NoErr) && (result != MemErr)) {
		reporterr(result,"pcx1.load()");
		return;
	}
	result = pcx2.load(Bestfit);
	if ((result != NoErr) && (result != MemErr)) {
		reporterr(result,"pcx2.load()");
		return;
	}
	result = pcx3.load(Bestfit);
	if ((result != NoErr) && (result != MemErr)) {
		reporterr(result,"pcx3.load()");
		return;
	}

	// display the images using various fade types with a 1 second delay
	// between successive images.

	pcx1.display(SoftFade);
	delay(1000);
	pcx1.remove(SplitHorizDissolve);
	pcx2.display(SlideVerticalWipe);
	delay(1000);
	pcx2.remove(SoftFade);
	pcx3.display(SplitVerticalDissolve);
	delay(1000);
	pcx3.remove(SnapWipe);

	settextmode();
	return;
}



E. Support

Support will be provided for this tool where and as possible through mess-
ages posted to 76605,2346 in the Game Design section (sec. 11) of the Gamers
Forum on Compuserve. Sorry, no telephone support is possible.

