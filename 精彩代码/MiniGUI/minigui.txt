下 面是找到的关于miniGUI的一些hints，应该覆盖了miniGUI使用中的很多问题，不过，个人觉得，在移植miniGUI至某个特殊平台时，关 于系统的经验还是很重要的，甚至超过下面这些小技巧的重要性；另外，仔细阅读文档也是相当重要的一环，仔细读文档能帮助你避免很多麻烦。不过这份文档当初 是拿来我自己参考的，所以格式还有排版以及完整性都比较欠缺，不过还是希望能对象我这样初用miniGUI的人有所帮助。另外，十分感谢kongmin, piano,armix诸位的讨论，没有他们前面的摸索，我们这些后来人要走不少弯路。 
1．Framebuffer支持：使用miniGUI时，需要系统启动framebuffer支持，在lilo.conf中添加一行：
vga=0x0317
在启动时进入framebuffer模式，也可用fbset设置；

2．如果启动时提示init错误，可以考虑给lilo传递init参数：
init=/bin/sh rw

3.如果miniGUI启动错误，考虑可能是以下原因：
A)没有启动framebuffer，即lilo.conf中的vga=XXXX，显示模式参照表如下：
640x480 800x600 1024x768 1280x1024 
256 0x3010x3030x3050x307 
32k  0x3100x3130x3160x319 
64k  0x3110x3140x3170x31A 
16M  0x3120x3150x3180x31B
B)启动了framebuffer，但无fb设备文件，可以自己创建/dev/fb0文件：
mknod fb0 c 29 0
C)miniGUI需要/var/tmp目录，如果不存在也会导致错误；


4. MiniGUI提供抓屏，用PrintScr键，抓到的图片为tmp模式，存在当前目录下；

5.有些时候，在试了很多方法之后设备仍然不能使用，可以考虑换个知名品牌的硬件试试，会有惊喜；

6．MiniGUI需要Unix Domain socket和System V IPC支持，内核里需要这两个；

7． 启动时的输入条可以用ctrl键关闭/启动，不过可能响应比较慢，要多摁几下；另外，也可以通过配置MiniGUI.cfg文件里的imenumber选项：
[imeinfo]
imenumber=2
将imenumber＝2改为imenumber＝0，启动时就不会出现输入条了；

8．iniGUI对串口鼠标的支持：
MiniGUI 的 Native IAL engine 目前不支持串口鼠标。 
如果要使用鼠标，可以通过 gpm 程序： 
1. 运行 gpm -k 命令杀掉正在运行的 gpm。 
2. 运行 mouse-test 命令确认自己的鼠标设备和协议。 
3. 运行 gpm，指定鼠标设备和协议： 
gpm -R -t <yourmousetype> -m <yourmousedevice> 
4. 编辑 /etc/MiniGUI.cfg 文件，将 mtype 设置为 gpm。 
 将 mdev 设置为 /dev/gpmdata。 
重新启动就OK了。
注意：用gpm设置鼠标格式的时候，可以使用-R参数，gpm 的 -R 参数是指定将原有鼠标协议转换成哪种鼠标协议，并 出现在 /dev/gpmdata 文件上的。 
gpm -R -t ms -m /dev/psaux
ms3 这种鼠标协议目前的 ial 引擎中 gpm 类型的设备所不支持的。
9．Framebuffer选项需要在内核中打开试验选项，即第一项：
Code maturity level options－》Prompt for development and/or incomplete code/drivers

10.popt.h文件的用处：
这东西专门用于命令行解析，如果你不准备使用miniGUI的虚拟控制终端，大可以将其扔掉（我就把它给扔了：））。还有不少交叉编译环境都不支持这玩意，小心点哦。 如果你要在目标版上支持控制终端，内核得有pty与pts支持

11.关于i810的framebuffer支持：
i810 的确是个令人郁闷的显示芯片。Linux 内核中没有对这个显示芯片的 FrameBuffer 
支持（除标准的 VGA16 FrameBuffer 之外）。 

网络上有一个专门为 i810 编写的 FrameBuffer 驱动程序，以下是配置步骤： 

The steps described here are given by leon, and have been tested on 
RedHat Linux 7.1, Linux kernel 2.4.2. 

1, get the i810fb tar ball -- i810fb_1.0x.tbz 
which is compressed by bz2. 
you can get it from http://www.visuelle-maschinen.de/ctfb/i810/ 

2, ucompress the tarball (using 'bunzip2' and 'tar' commands), and copy the i810fb.c i810fb.h 
to your kernel directory: 
/usr/src/linux-2.4/drivers/video 

4, modify the file: /usr/src/linux-2.4/drivers/video/fbmem.c 

1) add these lines as declaration: 

#ifdef CONFIG_FB_I810 
extern int i810fb_init (void); 
extern int i810fb_setup (char*); 
#endif 

before lines: 

static struct { 
const char *name; 
int (*init)(void); 
int (*setup)(char*); 
} fb_drivers[] __initdata = { 
... 

2) add these lines as the entry for i810 FrameBuffer driver: 

#ifdef CONFIG_FB_I810 
{ "i810fb", i810fb_init, i810fb_setup }, 
#endif 

before lines: 

#ifdef CONFIG_FB_VESA 
{ "vesa", vesafb_init, vesafb_setup }, 
#endif 
... 

3, if you compile this driver into the kernel 2.4.0 or above, 
you should modify the file: /usr/src/linux-2.4/drivers/char/agp/agpgart_be.c 

Current version: 
---------------- 
static int __init agp_init(void) 
{ 
init ret_val; 
... 

Change to: 
---------- 
int __init agp_init(void) 
{ 
static int ret_val = 0; 
static int woman = 0; 
if (woman) return ret_val; 
woman = 1; 
... 

5, edit the Makefile in the directory: /usr/src/linux-2.4/drivers/video 
add line: 

obj-$(CONFIG_FB_I810) += i810fb.o 

6, edit the Config.in in the directory: /usr/src/linux-2.4/drivers/video 
add these lines: 

if [ "$CONFIG_PCI" = "y" ]; then 
bool ' i810 support' CONFIG_FB_I810 
fi 

below the lines: 

bool 'Support for frame buffer devices (EXPERIMENTAL)' CONFIG_FB_RIVA 

if [ "$CONFIG_FB" = "y" ]; then 
define_bool CONFIG_DUMMY_CONSOLE y 
if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then 
if [ " $CONFIG_PCI" = "y" ]; then 
tristate ' nVidia Riva support (EXPERIMENTAL)' CONFIG_FB_RIVA 
fi 

7, exexute the 'make menuconfig' 
a, make sure: 
Character devices ---> 
<*> /dev/agpgart (AGP Support) 
・  Intel I810/I815 (on-board) support 
b, make sure: 
Console drivers ---> 
Frame-buffer support ---> 
・  i810 support 

8, compile the kernel image: 

make dep 
make bzImage 

9, then cp your-bzImage /boot 

10, edit /etc/lilo.conf: 
add lines: 

image = /boot/your-bzImage 
append = "video=i810fb:x:1280,xv:1280,y:1024,yv:1024, \ 
depth:16,pclk:7800,le:248,ri:16,up:38,lo:1, \ 
hs:144,vs:3,sync=3,vmode:0,accel:0,font:VGA8x8" 
initrd = /boot/initrd 
label = i810fb 

note: if your monitor doesn't support the 1280x1024 mode 
you can add this lines instead: 

image = /boot/your-bzImage 
append = "video=i810fb:x:1024,xv:1024,y:768,yv:768, \ 
depth:16,pclk:15384,le:168,ri:8,up:29,lo:3, \ 
hs:144,vs:6,sync=3,vmode:0,accel:0,font:VGA8x8" 
initrd = /boot/initrd 
label = i810fb 

This is a 1024x768x16bpp mode with 60Hz vertical frequency. 

11, Run 'lilo' command. 

12, Congratulations!! you can reboot your computer now!


12.移植miniGUI的心得：
应上头要求，我花了三天时间把miniGUI 1.00挪上了mips VR4181(内核vrlinux). 
以下供大家参考： 
  编译所需头文件主机x86与mips不同，可能会引起编译出错； 
  触摸屏接口用microWindow的就行，它带有校正功能，很不错； 
  上板子时遇到莫名其妙的共享内存操作错误，重倒几次后问题又奇怪地消失了（why？）。

13.i810/815主板的framebuffer攻略：
经历了2天的痛苦 
我终于让我的815上出现了企鹅的LOGO了 
而且fbset能够列出显示 
如果是815/810的同志们再遇到FB问题的话 
我愿意在这里解答问题 
其实让815/810（内置显卡）支持FB说白了不是太难 
1.下载一位洋人为815/810写的FB驱动（内付详细安装说明） 
2.按照那位洋人说的修改/linux/Driver（内核的Driver目录--内核可使用原来的亦可下载其他版本的--注意洋人在安装说明中所说的驱动要求的内核版本）下的部分文件 
3.重新make内核（这一步需要参照www.minigui.org/cdoc.htm里的framebuffer配置方法） 
4.重起机器应该就能看见企鹅了（反正我是按照这个方法一次就成功的） 
有问题的话欢迎提出 

i810fb_1.08.tbz的下载地址 
http://www.visuelle-maschinen.de/ctfb/i810/

14.又一案例：
现象：我用的是EP7212的板子，BlueCat的开发平台，下载了三个资源文件，libminiGUI1.1.0pre7,mde-0.2.7，资源文件安装了，然后解开libminiGUI1.1.0， 
运行./autogen.sh，再运行./configure,再运行make，出现这么一个错误： 
Making all in server 
make[3]: Entering directory '/BlueCat/demo.clep7212/developer/src/minigui/libminigui-1.1.0/src/server' 
/bin/sh ../../libtool --moe=complile gcc -DHAVE_CONFIG_H -I. -I. -I../.. -I../.. 
/include -I../include -g -02 -D__MINIGUI_LIB__ -02 -Wall -Wstrict-prototypes 
-pipe -DNDEBUG -c server.c 
gcc -DHAVE_CONFIG_H -I. -I. -I../.. -I../../include -I../include -g -02 -D__MINIGUI_LIB__ -02 -Wall -Wstrict-prototypes -pipe -DNDEBUG -Wp,-MD,.deps/server.pp -c server.c -o server.o 
../../gcc/pexecute.c:245: Internal compiler error in function pexecute 
make[3]: ***[server.lo] Error 1 
make[3]: Leaving directory '/BlueCat/demo.clep7212/developer/src/minigui/libminigui-1.1.0/src' 
make[1]: *** [all-recursive] Error1

解决方法：搞定！http://arch.freeciv.org/freeciv-dev-199902/msg00522.html 


Todd Goodman on Sun, 28 Feb 1999 10:10:28 -0600 (CST)   

[Date Prev] [Date Next] [Thread Prev] [Thread Next] [Date Index] [Thread Index] 

[Freeciv-Dev] Building Under Cygwin   

To: <freeciv-dev@freeciv.org> 
Subject: [Freeciv-Dev] Building Under Cygwin 
From: "Todd Goodman" <tsg1@earthlink.net> 
Date: Sun, 28 Feb 1999 11:05:28 -0500 
Sender: freeciv-dev-bounce@freeciv.org 

-------------------------------------------------------------------------------- 

I just wanted to let you know that the latest CVS does not build 
without changes on Cygwin. 

The problem is that the gcc distributed with Cygwin 20.1 barfs 
on the -pipe option with an internal compiler error: 

make all-recursive 
Making all in data 
Making all in default 
make[3]: Nothing to be done for `all'. 
Making all in civ1 
make[3]: Nothing to be done for `all'. 
Making all in classic 
make[3]: Nothing to be done for `all'. 
Making all in common 
gcc -DHAVE_CONFIG_H -I. -I. -I..   -g -O2 -Wall -pipe -c capability.c 
/home/noer/src/b20/comp-tools/devo/gcc/pexecute.c:245: Internal compiler 
error in function pexecute 
make[2]: *** [capability.o] Error 33 
make[1]: *** [all-recursive] Error 1 
make: *** [all-recursive-am] Error 2 
/usr/local/src/freeciv/freeciv> 

I fixed it by patching configure.in to no longer use the -pipe option. 
I'm going to be reporting this problem to the Cygwin list too. 

My patch to configure.in is: 

  --- configure.in        Sun Feb 28 10:52:22 1999 
  +++ configure.in.orig   Sun Feb 28 10:51:40 1999 
  @@ -104,8 +104,7 @@ 
   dnl  AC_PROG_MAKE_SET 

   if test -n "$GCC"; then 
  -   dnl CFLAGS="$CFLAGS -Wall -pipe" 
  -   CFLAGS="$CFLAGS -Wall" 
  +   CFLAGS="$CFLAGS -Wall -pipe" 
   fi 

   if test "$CVS_DEPS" = "maybe"; then 

Thanks, 

Todd 

-------------------------------------------------------------------------------- 

Prev by Date: [Freeciv-Dev] trouble with SuSE.& freeciv 
Next by Date: Fwd: Re: [Freeciv-Dev] A city doesn't have a mine beneath it 
Prev by thread: Re: [Freeciv-Dev] trouble with SuSE.& freeciv 
Next by thread: [Freeciv-Dev] Pre-Alpha WIN 95/98/NT Installation Available to Test 
Index(es): 
Date 
Thread

15.miniGUI的裁减
裁剪 MiniGUI 的三个步骤： 
1. 在运行 ./configure 时进行定制，取消某些不需要的功能。 
2. 修改 /etc/MiniGUI.cfg，删除某些不需要的字体文件。比如， 
 如果你只使用 GB2312、12 点阵的字体，就可以只保留系统字体， 
 而删除其他的字体。当然了，删除的方法是修改 fontnumber 键 
 的值，而不是删除这个段。对应的那些字体文件，就可以从系统 
 中删除了。 
3. 那三个资源包中实际有用的东西，都列在了 /etc/MiniGUI.cfg 文件中。 
 如果哪个文件没有出现在 /etc/MiniGUI.cfg 中，就删除这个文件。 

这样，一般可以将 MiniGUI 及其所使用的文件缩小到 2M 以内，有的情况 
下可以缩小到 1M 以内。
移植时，光修改配置文件是不够的。 默认情况下，许多针对具体嵌入式系统的 IAL 引擎并没有编译到 MiniGUI 函数库 当中。你要在运行 ./configure 脚本的时候指定所需要的引擎。 具体方法，可参阅 http://www.minigui.org/cdoc.shtml 中有关配置的文章。 也可以参阅源代码当中的 ./buildlib-* 文件。
如果你使用的是 MiniGUI 1.1.0PreX 版本，请使用老 GAL 引擎来提供 
对 4bpp 灰度 LCD 的支持。也就是在配置时使用 
--disable-newgal 
选项。新的 GAL 引擎，不支持低于 8 bpp 的演示模式。 
另外，你还需要在配置时指定 
--enable-fblin4 
--enable-ep7211ial 
等选项。

15.编译时的-m286和-m486选项的作用和意义：
from gcc-HowTo中文版:
这 之中最重要的有是-m386和-m486这两种，用来告诉gcc该把正在编译的程序代码视作专为386或是486机器所写的。不论是用哪一种-m来编译程 序代码，都可以在彼此的机器上执行，-m486编译出来的码会比较大，不过拿来在386的机器上跑也不会比较慢就是了。 
目前尚无- mpentium或是-m586的旗号。Linus建议我们可以用-m486 -malign-loops=2 -malign-jumps=2 -malign-functions=2来得到最佳编码的486程序代码，这样做正好就可以避免alignment（Pentium并不需要）有过大的 gaps发生。

16.MiniGUI移植到EP7211的问题：
我最近几天一直忙着移植MiniGUI到EP7212板上，碰到不少问题，在此一次列出，请大家指点： 

1.Cygwin下编译pexecute.c错误问题，去掉autogen.sh产生的configure.in中的-pipe； 

2.Libminigui-1.1.0编译根据舵主手谕：./configure --disable-newgal 
--enable-fblin4 --enable-ep7211ial 。编译ok,但我编译的libminigui都是静态库。我在redhat上同样编译却是动态连接库，奇怪？ 

3.库文件找不到，Makefile中手工加-lm；，编译后文件都2M多，如何编译成动态库？ 

4.编译mde-0.2.7，bomb,same等程序出错，好像调用newgdi/下的attr.c中的函数出错，为什么调newgdi呢？我编译库时指定了--disable-newgal，难道mde-0.2.7不能运行在ep7212? 
不管三七二十一，删掉Makefile里的subdirs相关目录，先编译过了再说。 

5.仔细看发现InitEP7211Input（）函数里打开设备/dev/ts，还有一个文件/etc/ts.conf 
难道设备不用MiniGUI.CFG里指定的？ts.conf那来的？mtype=应该是什么？ 

6.strip mginit后，变成600多k，勉强倒到板上，运行出错，凭我的想象，修改 
  /etc/MiniGUI.cfg: 
  gal_engine=native 
  ial_engine=native 
  mdev=/dev/tpanel     #我用mknod -m 644 /dev/tpanel   c 10 12产生的 
  mtype=PS2            #我不清楚touchpanel改用什么，索性不改 
  defaultmode=320x240x4 
  运行，出现错误： 
Error in step 8: Can not initialize low level event! 
InitGUI failure when using /etc/MiniGUI.cfg as cfg file. 
看来时ial出错，查来查去好像init-lite.c文件调用引起，难道编译了lite版本？EP7212上能用lite版本么？

看来你还是做了许多研究，但没有找到主要问题。 
MiniGUI 中给出了针对 EP7211 的 IAL 引擎，但并没有针对 EP7212 的 IAL 引擎。 
如果两者不同，你需要自己编写一个引擎，就像 EP7211 的引擎一样，并且要在 
/etc/MiniGUI.cfg 文件中指定 ial_engine=ep7212，而不是 native。 
native 的 ial 引擎是用于 PC 的，操作的是键盘和鼠标，你用在你的 EP7212 板子 
上能行吗？ 
mdev 和 mtype 是给 IAL 引擎使用的一些可配置参数。某些 IAL 引擎（比如 EP7211） 
根本就没有可配置的选项，所以程序不用这些配置参数，直接将设备名称硬编码到 
代码当中了，所以，是否设置 mdev 和 mtype，这无关紧要。 
defaultmode 是用于新的 GAL 引擎的，你使用旧的 GAL 引擎，没有任何作用。 
对于你这种情况，建议如下： 
1. 在配置 MiniGUI 的时候，打开 Dummy ial 引擎，即使用如下的参数： 
 --enable-dummyial 
 其他的参数和你以前使用的一样。既然 EP7211 的引擎和你 EP7212 的引擎 
 不一样，就不需要使用这个引擎了。Dummy IAL 引擎是个什么工作都不做的 
 引擎。使用这个引擎你可以首先将 MiniGUI 在目标板上运行起来，然后再 
 进一步参照其他的引擎编写适合自己的引擎。 
2. 在 /etc/MiniGUI.cfg 中，指定如下设置： 
 gal_engine=native 
 ial_engine=dummy 
 其他参数可以忽略。 
至于无法生成动态库的问题，可能和你的编译环境设置有关，我就帮不上什么忙了。

17.newgal和gal的区别：newgal 只支持 8 位色以上的线性显示模式，功能强大， 
而低于 8 位色的那些模式（比如 16 色及低于 16 色的灰度等等）不被支持。
18.设置ial引擎的问题：
大家新年号！请问： 
在MiniGUI.cfg文件中，如设置 
ial_engine=Dummy 
则 mdev，mtype如何设置？ 
设置ial_engine=Dummy后，演示程序mginit能否运行？

那两个参数随便取值即可。 
在使用 Dummy 引擎之后，MiniGUI 是可以正常运行的， 
只是你无法控制程序而已，因为没有任何的输入。

19.系统时间对miniGUI也会有影响。譬如，如果系统时间不对，生成的文件时间比源文件旧，会导致make进行clock skew

20.桌面程序的层：
今天总算把MiniGUI给装上了，真爽呀！但是为什么不管运行什么程序都是在屏幕右边三分之二处有一条线把屏幕分成二部分了？

MiniGUI-Lite 原本是每个客户进程在自己的层中运行的。 
后来可以让许多进程在同一个层中运行，但不能互相重叠。 
那个线就是表示一个客户在一个层中所占有的矩形区域。

kongming大哥，你的意思是不是说，除了不能互相重叠之外，是可以在桌面上同时看到两个矩形区域，分别有不同的客户程序在运行呢？可是在mde中除了能看到一个客户程序和桌纸、任务栏外，即便还运行着别的客户程序也是看不到的呀。 
如果要做一个比较完善的窗口管理器的话，是不是可以做到“让许多进程在同一个层中运行，并能互相重叠”的效果呢，是不是还可以象windows下那样随意移动窗口的位置和改变窗口的大小呢？ 
我是新手，刚刚把MiniGUI安装好，还不懂其编程呢，所以问题很幼稚，请大侠们不要见笑，不吝赐教哟：）

那需要在运行程序时添加一个特殊的选项， 
比如： 
./fminigui -layer vcongui 
指定它加入某个层，否则会新建一个层。 
其实，在许多嵌入式设备当中，有这种层，以及进程内的多窗口完全支持，就足够了。

21.在Embedded Planet上安装MiniGUI.1.1.0的注意事项：
1．修改helio.c文件 
      #define _HELIO_BUTTON  1 
改为  #undef _HELIO_BUTTON 
2．修改configure文件 
     CC = “$ac_cv_prog_cc” 
改为 CC = ppc_8xx-gcc 
3．修改config.h文件 
     #undef  _EXT_CTRL_TREEVIEW 
改为 #define  _EXT_CTRL_TREEVIEW 
4．修改tools/目录下的Makefile文件： 
      LIBS = -lminigui 
改为：LIBS = -lminigui Clm 
5．taskbar.c中去掉 
hIMEwnd = IMEWindowEx……. 
6．配置使用build_helio 
7．头文件、四个库文件、资源文件以及配置文件MiniGUI.cfg都要复制到嵌入式系统的对应目录中。 
8．根据mginit目录中minigui.rc文件的要求将mginit及其它demo复制到相应目录下。

22.about鼠标的问题：
现在我的pc104平台上已经显示出bomb的画面，真令人激动。现在还有两个小问题想请教 
1。bomb只在屏幕上显示了一部分，功能正常，** 但我无法修改图形模式**， 
我的显卡（C&T 65535 1M）可以用SVGALib的测试程序，最高可设为1024x768x256 
我在MiniGUI.cfg中设置了 
[SVGALib] 
defaultmode=1024x768x256(1024x768x256或1024x768-256 ,1024x768x-8bpp，640x480-256) 
从bomb退出后均提示无效的图形模式。 
若设成：defaultmode=G1024x768x256（或G640x480x256） 则黑屏 
我看了网站上的文档，好象没有具体的说明,不知如何设 置 
2。我看网站上有贴是关于串行口鼠标支持的一段修改的程序（用ms3）,我下载后编译成功，但鼠标无法驱动。是否此修改不能在SVGALib上用？ 

第一个问题： 
正确的设置应该是 

[SVGALib] 
defaultmode=G1024x768x256 

如果是黑屏，可能是驱动不支持的原因，也许要修改 /etc/vga/libvga.conf 中的设置。 

第二个问题： 
那段程序是用来支持 native IAL 引擎的，SVGALib 的鼠标支持，需要修改 
/etc/vga/libvga.conf 文件。 

将 mousetype 设置为 Microsoft，并正确设定鼠标设备文件。

我 现在用PS2鼠标，显卡正常的设置应该是G320x200x256 ,我看了一下文件src/gal/svgalib.c 似乎在模式非法时缺省返回G320x200x256,然后我将MiniGUI.cfg的模式也改成这个后，可以正常。改成G640x480x256  ,或G1024x768x256都会黑屏，但这两种模式我安装好SVGALib-1.4.0后运行其自带的vgatest测试程序都可以正常显示。不知 SVGALib图形引擎支持的模式，是否minigui-1.1.0都支持?黑屏跟其他设置有关吗，比如鼠标，键盘？ 
 另外，在执行./configure ----disable-newgal --disable-nativegal --enable-svgalib后 似乎仍然没有将SVGALib编译进去，我看了以下生成的文件config.h,有一行 
/*undef _SVGALIB*/ 
必须还要加上--disable-lite生成的config.h里就有了#define _SVGALIB 1,不知是否是这样？ 

应该和鼠标键盘没有关系。 
至于配置选项，的确应该加上 --disable-lite，因为 MiniGUI-Lite 版本不能在 
SVGALIB 上运行。所以，我估计应该是这个问题造成的。


23.如何在启动的任务栏中添加自己的程序：
我们在redhat7.2上编译好minigui1.1.x后，准备学习在该环境下编译调试minigui应用程序。我们以源程序中附带的hello world程序为例。该程序要求画一个窗口并在其中显示Hello world。 
  于是大家摸索如何在mginit中添加一个图标，并使该图标的点击启动hello world程序。基本做法如下： 
  1、在mde0.3.0中添加一个hello文件包，并将hello world源程序复制到其中。 
  2、将notebook中的Makefile等三个文件以及res包复制到hello中。 
  3、分别修改三个make文件，将其中的notebook字样全部替换为hello。 
  4、用linux下的任何图像编辑工具设计一个图标存为hello.png和hello.gif，存到mginit包下的res包中。 
  5、修改mginit包下的mginit.rc文件：将其中的nr＝10，改为nr＝11； 
       复制其中的一组程序段到最后，段头改为apply10；其中对应的字样也改为hello 
  6、修改mginit包下的三个make文件，其中有一个地方列出了很多应用程序可执行文件名，在其中添加hello。 
  至此，基本修改结束。执行make命令。成功后，运行mginit，则应能看到mginit窗口下多了一个图标，那就是你设计的。点击之，应该能看到hello world程序运行结果。 
  不一定描述准确，仅供参考。
24. miniGUI应用程序的问题：
各位兄弟： 
  大家好!我做了一个应用，使板子一上电Linux引导之后就自动运行MiniGUI服务器进程和MiniGUI应用程序，但发现服务器进程mginit每 次均能正常运行，而应用程序时好时坏(有时能起来，有时却起不来)。我估计这种现象可能是服务器与应用程序之间的通讯造成的(即服务器还没有准备好，而应 用程序却开始运行了)。但发现在mginit&之后加延时再跑应用程序也存在着这个问题。下面是我写的简单服务器进程mginit.c和应用程序 test.c,可能存在着桌面、层、通讯方面的问题与不足，请大家不吝赐教，谢谢! 

  显示：单色LCD(320*240) 

  一、服务器进程mginit.c 
   
  int DisplayImeProc(HWND hWnd, int nMsg, WPARAM wParam, LPARAM lParam); 

  int MiniGUIMain (int args, const char* arg[]) 
{ 
  MSG Msg; 
  MAINWINCREATE CreateInfo; 
  HWND hMainWnd; 


  if (!ServerStartup ()) 
  { 
      fprintf(stderr, "Can not start mginit.\n"); 
      return 1; 
  } 

   
  if(SetDesktopRect (0, 207, 320, 240)==0) 
  { 
     fprintf(stderr, "Can not get the required desktop rectangle.\n"); 
     return 2; 
  } 
   

  if(!InitMiniGUIExt()) 
  { 
   
     fprintf(stderr, "Can not init mgext library.\n"); 
     return 3; 
  } 

  CreateInfo.dwstyle =  WS_BORDER; 
  CreateInfo.dwExstyle = WS_EX_NONE; 
  CreateInfo.hMenu =(HMENU)NULL; 
  CreateInfo.hCursor =(HCURSOR)(IDC_ARROW); 
  CreateInfo.hIcon = GetSmallSystemIcon (IDI_APPLICATION); 
  CreateInfo.lx=0; 
  CreateInfo.ty=207; 
  CreateInfo.rx=320; 
  CreateInfo.by=240; 
  CreateInfo.hMenu=(HMENU)NULL; 
  CreateInfo.MainWindowProc=DisplayImeProc; 
  CreateInfo.iBkColor=COLOR_lightwhite; 
  CreateInfo.dwAddData=0; 
  CreateInfo.hHosting=HWND_DESKTOP; 

  hMainWnd=CreateMainWindow(&CreateInfo); 
   
     
  if(hMainWnd==HWND_INVALID) 
  { 
       fprintf(stderr,"Main Window invalid!\n"); 
       return -1; 
  } 
   
  ShowWindow(hMainWnd,SW_HIDE); 
   
   
  while(GetMessage(&Msg,hMainWnd)) 
  { 
    DispatchMessage(&Msg); 
  } 
   
  MainWindowThreadCleanup(hMainWnd); 
   
  return 0; 
} 


int DisplayImeProc(HWND hWnd, int nMsg, WPARAM wParam, LPARAM lParam) 
{ 
 
 switch (nMsg) 
 { 
     case MSG_CREATE: 
    { 
IMEWindow(hWnd); 
return 0; 
    } 
 } 
 
return DefaultMainWinProc(hWnd, nMsg, wParam, lParam); 
   
} 

二、应用程序test.c 
 int MiniGUIMain (int args, const char* arg[]) 
{ 
  MSG Msg; 
  MAINWINCREATE        CreateInfo; 
  HWND hMainWnd; 
  HHOOK hhook; 

  SetDesktopRect (0, 0, 320, 207); 
  CreateInfo.dwstyle =  WS_BORDER; 
  CreateInfo.dwExstyle = WS_EX_NONE; 
  CreateInfo.hMenu =(HMENU)NULL; 
  CreateInfo.hCursor = GetSystemCursor (IDC_ARROW); 
  CreateInfo.hIcon = GetSmallSystemIcon (IDI_APPLICATION); 
  CreateInfo.MainWindowProc = MainWinProc; 
  CreateInfo.lx = 0; 
  CreateInfo.ty = 0; 
  CreateInfo.rx = 320; 
  CreateInfo.by = 207; 
  CreateInfo.iBkColor=COLOR_lightwhite; 
  CreateInfo.dwAddData = 0; 
  CreateInfo.hHosting = HWND_DESKTOP; 
   
  if(!InitMiniGUIExt()) 
  { 
    return 1; 
  } 
   
  hMainWnd = CreateMainWindow (&CreateInfo); 
   
  if (hMainWnd == HWND_INVALID) 
      return 2; 

  ShowWindow (hMainWnd, SW_SHOWNORMAL); 
  hhook = RegisterKeyMsgHook(hMainWnd, AllKeyboardProc); 
  while( GetMessage (&Msg, hMainWnd)) 
  { 
  TranslateMessage(&Msg); 
      DispatchMessage (&Msg); 
  } 

  UnregisterHook (hhook); 
  MainWindowThreadCleanup (hMainWnd); 

  return 0; 
} 

三、存在的问题： 
  1.mginit进程与应用程序进程test存在着通讯上的问题(即服务器进程能正常工作，而 应用程序有时能起来，有时却起不来)。如何解决？ 
    具体实现，在/etc/rc.sysinit文件中加入： 
        insmod ...    //加入一些驱动，如DOC、键盘。 
        mginit & 
        ./test & 
  2.在应用程序中的编辑框中，按左右方向键不能在编辑框中的字符间移动，但左右方向键在MiniGUI上能通过按键消息得到。是否与Caret的设置有关？ 

  3.服务器与应用程序中相应的配置是否还存在着问题？ (主要是桌面、层方面)

1. 如果是你怀疑的那个愿意，你可以试着在 mginit 当中 fork 然后执行 test 程序。 
 就像 MDE 中的 mginit 那样。 
2. 是在你的目标板上不正常吗？ 
3. 似乎没有什么问题。

1.为了使mginit快速启动，我把mginit和运行库放到了FLASH中了，而应用程序、字库、输 入法放在DOC中。但大多数情况下，应用程序都能起来。 

2.板子好像没有问题，但可能驱动大多造成了服务器与应用间的通讯。我有DOC、AD、显示、键盘等驱动。 
至于光标，跑例子程序中的notebook，左右方向键仍然不能在字符间移动。

Kong Ming: 
 您好! 
 问题已经解决，原来是我在mginit中处理MSG_PAINT消息后使用了return 0;语句，而应使用break;结束,从而引起了mginit 死机!还有光标问题基本上已得到解决，原来我在键盘驱动中处理左右方向键时，扫描码没有按照MiniGUI的要求做。修改之后，光标已能在Edit框中左 右移动了，但在ComboBox框中设置了焦点，仍不出现闪烁的竖线光标，请问是什么原因？

请问你是怎么设置 ComboBox 控件的焦点的？

使用SetFocus(hComboOperator);其中，hComboOperator是所创建组合框的窗口柄。谢谢!

似乎不应该出问题啊。你用的是什么版本的 MiniGUI？检查一下 src/control/combobox.c 中 SETFOCUS 消息的处理。

我用的是MiniGUI1.10Pre9,在这个版本中怎么没有SETFOCUS的消息处理呢？

那看来是版本太老的原因，建议你还是升级到最新的 1.2.1 吧。

24.如果mginit不能正常启动的话，可以考虑减少mginit.rc的nr值，譬如修改为6，这个文件是mginit的配置文件。
